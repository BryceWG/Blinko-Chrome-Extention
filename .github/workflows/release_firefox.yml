name: Package and Release Firefox Extension

on:
  workflow_dispatch: # 允许手动触发
  push:
    branches:
      - firefox # 仅在 firefox 分支上触发
    paths:
      - 'manifest.json' # 仅当 manifest.json 文件发生更改时触发

jobs:
  build-and-release-firefox:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 创建 Release 需要此权限

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 获取完整的git历史记录用于生成changelog

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # 您可以指定其他 Node.js 版本

      - name: Install web-ext
        run: npm install -g web-ext

      - name: Get extension info from manifest
        id: get_info
        run: |
          EXT_VERSION=$(jq -r .version manifest.json)
          # 优先使用 browser_specific_settings.gecko.id 作为文件名基础
          # 如果不存在，则回退到仓库名称
          GECKO_ID=$(jq -r '.browser_specific_settings.gecko.id // ""' manifest.json)
          REPO_NAME=$(echo "${{ github.repository }}" | awk -F'/' '{print $2}')
          
          if [ -n "$GECKO_ID" ]; then
            # 清理 GECKO_ID 以用作文件名 (将 @ 和 . 替换为 _)
            BASE_FILENAME=$(echo "$GECKO_ID" | sed 's/[@.]/_/g')
          else
            BASE_FILENAME=$REPO_NAME
          fi

          # 构建最终的 ZIP 文件名
          ARTIFACT_NAME="${BASE_FILENAME}-${EXT_VERSION}.zip"
          
          echo "VERSION=${EXT_VERSION}" >> $GITHUB_OUTPUT
          echo "ARTIFACT_NAME=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          
          echo "Extension Version: $EXT_VERSION"
          echo "Gecko ID: $GECKO_ID"
          echo "Repository Name: $REPO_NAME"
          echo "Base Filename for Artifact: $BASE_FILENAME"
          echo "Expected Artifact Name: $ARTIFACT_NAME"

      - name: Build unsigned Firefox extension
        id: build_ext
        run: |
          ARTIFACT_FILENAME="${{ steps.get_info.outputs.ARTIFACT_NAME }}"
          echo "Attempting to build extension and name it: $ARTIFACT_FILENAME"
          
          # 首先构建未签名的 zip 文件
          web-ext build --source-dir . --filename "$ARTIFACT_FILENAME" --overwrite-dest
          
          if [ -f "$ARTIFACT_FILENAME" ]; then
            echo "Unsigned extension built successfully: $ARTIFACT_FILENAME"
            echo "UNSIGNED_ARTIFACT_PATH=${ARTIFACT_FILENAME}" >> $GITHUB_OUTPUT
          else
            echo "Error: Built artifact '$ARTIFACT_FILENAME' not found in the current directory!"
            echo "Listing current directory contents:"
            ls -la
            # web-ext 可能会在 web-ext-artifacts/ 目录中输出，如果 --filename 有问题
            if [ -d "web-ext-artifacts" ]; then
              echo "Listing web-ext-artifacts/ directory contents:"
              ls -la web-ext-artifacts/
            fi
            exit 1
          fi
          
      - name: Sign Firefox extension
        id: sign_ext
        env:
          AMO_JWT_ISSUER: ${{ secrets.AMO_JWT_ISSUER }}
          AMO_JWT_SECRET: ${{ secrets.AMO_JWT_SECRET }}
        run: |
          # 检查 AMO API 密钥是否设置
          if [ -z "$AMO_JWT_ISSUER" ] || [ -z "$AMO_JWT_SECRET" ]; then
            echo "警告：AMO_JWT_ISSUER 或 AMO_JWT_SECRET 未设置，跳过签名步骤。"
            echo "SIGNED=false" >> $GITHUB_OUTPUT
            echo "ARTIFACT_PATH=${{ steps.build_ext.outputs.UNSIGNED_ARTIFACT_PATH }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # 开始签名流程
          echo "使用 AMO API 密钥签名扩展..."
          VERSION="${{ steps.get_info.outputs.VERSION }}"
          
          # 使用 web-ext sign 命令签名
          # --channel=listed 表示在 AMO 上公开列出；如果是私有分发，请改为 unlisted
          # 注意：如果 addon ID 已在 AMO 上注册，必须使用相同的 ID
          web-ext sign \
            --source-dir . \
            --api-key="$AMO_JWT_ISSUER" \
            --api-secret="$AMO_JWT_SECRET" \
            --channel=listed \
            --timeout=600000
          
          # web-ext sign 命令成功后会在 web-ext-artifacts 目录中创建签名的 .xpi 文件
          if [ -d "web-ext-artifacts" ]; then
            # 查找最新的 .xpi 文件
            SIGNED_XPI=$(find web-ext-artifacts -type f -name "*.xpi" | sort -r | head -n 1)
            
            if [ -n "$SIGNED_XPI" ]; then
              echo "签名的 XPI 文件成功创建: $SIGNED_XPI"
              echo "SIGNED=true" >> $GITHUB_OUTPUT
              echo "ARTIFACT_PATH=${SIGNED_XPI}" >> $GITHUB_OUTPUT
            else
              echo "签名失败：未找到 .xpi 文件"
              echo "SIGNED=false" >> $GITHUB_OUTPUT
              echo "ARTIFACT_PATH=${{ steps.build_ext.outputs.UNSIGNED_ARTIFACT_PATH }}" >> $GITHUB_OUTPUT
            fi
          else
            echo "签名失败：web-ext-artifacts 目录不存在"
            echo "SIGNED=false" >> $GITHUB_OUTPUT
            echo "ARTIFACT_PATH=${{ steps.build_ext.outputs.UNSIGNED_ARTIFACT_PATH }}" >> $GITHUB_OUTPUT
          fi

      - name: Generate Changelog
        id: changelog
        run: |
          # 获取最近的两个tag，特别是关注firefox相关的标签
          LATEST_TAG=$(git describe --tags --abbrev=0 --match "*firefox*" 2>/dev/null || echo "")
          
          # 如果没有找到firefox特定的标签，尝试获取任何标签
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          fi
          
          # 尝试获取上一个标签
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 $LATEST_TAG^ 2>/dev/null || echo "")
          
          # 如果没有找到标签，则使用一些合理的默认值
          if [ -z "$LATEST_TAG" ]; then
            # 如果没有任何标签，使用当前提交作为最新标签
            LATEST_TAG=$(git rev-parse --short HEAD)
            echo "未找到标签，使用当前提交 $LATEST_TAG 作为参考点"
          fi
          
          if [ -z "$PREVIOUS_TAG" ]; then
            # 如果只有一个标签，获取从第一个提交到该标签的范围
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD | head -n 1)
            echo "未找到上一个标签，使用首次提交 $PREVIOUS_TAG 作为参考点"
          fi
          
          echo "最新标签: $LATEST_TAG"
          echo "上一个标签: $PREVIOUS_TAG"
          
          # 生成格式化的changelog
          echo "## 更新内容" > changelog.md
          echo "" >> changelog.md
          
          # 获取两个标签之间的所有提交
          git log --pretty=format:"* %s (by @%an in %h)" $PREVIOUS_TAG..$LATEST_TAG | grep -v "Merge" >> changelog.md
          
          echo "" >> changelog.md
          echo "## 完整更新日志" >> changelog.md
          echo "[${PREVIOUS_TAG}...${LATEST_TAG}](https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${LATEST_TAG})" >> changelog.md
          
          CHANGELOG=$(cat changelog.md)
          # 将多行字符串转换为GitHub Actions可以处理的格式
          CHANGELOG="${CHANGELOG//%/%25}"
          CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
          CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"
          
          echo "CHANGELOG=${CHANGELOG}" >> $GITHUB_OUTPUT
          cat changelog.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.sign_ext.outputs.ARTIFACT_PATH }}
          name: Firefox Release v${{ steps.get_info.outputs.VERSION }}
          # 为 Firefox 版本的标签添加 -firefox 后缀以区分
          tag_name: v${{ steps.get_info.outputs.VERSION }}-firefox 
          body: |
            # Blinko Firefox 扩展 v${{ steps.get_info.outputs.VERSION }}
            
            签名状态: ${{ steps.sign_ext.outputs.SIGNED == 'true' && '已签名 (.xpi)' || '未签名 (.zip)' }}
            文件: ${{ steps.sign_ext.outputs.ARTIFACT_PATH }}
            
            ${{ steps.changelog.outputs.CHANGELOG }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 